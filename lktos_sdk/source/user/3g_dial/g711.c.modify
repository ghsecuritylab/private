int BIAS = 0x84; //132, or 1000 0100
int MAX = 32635; //32767 (max 15-bit integer) minus BIAS

char linear2ulaw(int pcm) //16-bit
{
    //Get the sign bit. Shift it for later 
    //use without further modification
    int expMask;
    char mulaw;
    int sign = (pcm & 0x8000) >> 8;
    //If the number is negative, make it 
    //positive (now it's a magnitude)
    if (sign != 0)
        pcm = -pcm;
    //The magnitude must be less than 32635 to avoid overflow
    if (pcm > MAX) pcm = MAX;
    //Add 132 to guarantee a 1 in 
    //the eight bits after the sign bit
    pcm += BIAS;

    /* Finding the "exponent"
    * Bits:
    * 1 2 3 4 5 6 7 8 9 A B C D E F G
    * S 7 6 5 4 3 2 1 0 . . . . . . .
    * We want to find where the first 1 after the sign bit is.
    * We take the corresponding value from
    * the second row as the exponent value.
    * (i.e. if first 1 at position 7 -> exponent = 2) */
    int exponent = 7;
    //Move to the right and decrement exponent until we hit the 1
    for (expMask = 0x4000; (pcm & expMask) == 0; 
         exponent--, expMask >>= 1) { }

    /* The last part - the "mantissa"
    * We need to take the four bits after the 1 we just found.
    * To get it, we shift 0x0f :
    * 1 2 3 4 5 6 7 8 9 A B C D E F G
    * S 0 0 0 0 0 1 . . . . . . . . . (meaning exponent is 2)
    * . . . . . . . . . . . . 1 1 1 1
    * We shift it 5 times for an exponent of two, meaning
    * we will shift our four bits (exponent + 3) bits.
    * For convenience, we will actually just shift
    * the number, then and with 0x0f. */
    int mantissa = (pcm >> (exponent + 3)) & 0x0f;

    //The mu-law byte bit arrangement 
    //is SEEEMMMM (Sign, Exponent, and Mantissa.)
    mulaw = (char)(sign | exponent << 4 | mantissa);

    //Last is to flip the bits
    return (char)~mulaw;
}

#if 0
short ulaw2linear(char mulaw)
{
    //Flip all the bits
    mulaw = (char)~mulaw;

    //Pull out the value of the sign bit
    int sign = mulaw & 0x80;
    //Pull out and shift over the value of the exponent
    int exponent = (mulaw & 0x70) >> 4;
    //Pull out the four bits of data
    int data = mulaw & 0x0f;

    //Add on the implicit fifth bit (we know 
    //the four data bits followed a one bit)
    data |= 0x10;
    /* Add a 1 to the end of the data by 
    * shifting over and adding one. Why?
    * Mu-law is not a one-to-one function. 
    * There is a range of values that all
    * map to the same mu-law byte. 
    * Adding a one to the end essentially adds a
    * "half byte", which means that 
    * the decoding will return the value in the
    * middle of that range. Otherwise, the mu-law
    * decoding would always be
    * less than the original data. */
    data <<= 1;
    data += 1;
    /* Shift the five bits to where they need
    * to be: left (exponent + 2) places
    * Why (exponent + 2) ?
    * 1 2 3 4 5 6 7 8 9 A B C D E F G
    * . 7 6 5 4 3 2 1 0 . . . . . . . <-- starting bit (based on exponent)
    * . . . . . . . . . . 1 x x x x 1 <-- our data
    * We need to move the one under the value of the exponent,
    * which means it must move (exponent + 2) times
    */
    data <<= exponent + 2;
    //Remember, we added to the original,
    //so we need to subtract from the final
    data -= BIAS;
    //If the sign bit is 0, the number 
    //is positive. Otherwise, negative.
    return (short)(sign == 0 ? data : -data);
}
#else

#if 0
#define	SIGN_BIT	(0x80)		/* Sign bit for a A-law byte. */
#define	QUANT_MASK	(0xf)		/* Quantization field mask. */
#define	SEG_SHIFT	(4)		/* Left shift for segment number. */
#define	SEG_MASK	(0x70)		/* Segment field mask. */
short ulaw2linear(unsigned char	u_val)
{
	short		t;

	/* Complement to obtain normal u-law value. */
	u_val = ~u_val;

	/*
	 * Extract and bias the quantization bits. Then
	 * shift up by the segment number and subtract out the bias.
	 */
	t = ((u_val & QUANT_MASK) << 3) + BIAS;
	t <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;

	return ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));
}
#endif

int ulaw2linear(unsigned char ulawbyte)
{
     static int exp_lut[8] = { 0, 132, 396, 924, 1980, 4092, 8316, 16764 };
     int sign, exponent, mantissa, sample;
 
     ulawbyte = ~ulawbyte;
     sign = (ulawbyte & 0x80);
     exponent = (ulawbyte >> 4) & 0x07;
     mantissa = ulawbyte & 0x0F;
     sample = exp_lut[exponent] + (mantissa << (exponent + 3));
     if (sign != 0)
     {
         sample = -sample;
     }
 
     return sample;
}
#endif